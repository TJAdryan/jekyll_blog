# azure-pipelines.yml
# Trigger the pipeline on pushes to your content branch (e.g., 'main')
# trigger:
#   branches:
#     include:
#     - main # Or 'master', 'source', 'develop', etc., where your Jekyll source lives

# Use a Microsoft-hosted agent for your build.
# For public projects, you get unlimited minutes on these agents!
pool:
  vmImage: 'ubuntu-latest' # A recent Ubuntu image with Ruby/Bundler typically available

# Variables for easy customization
variables:
  # The branch on your GitHub repository that GitHub Pages serves from.
  # COMMON VALUES: 'gh-pages' (for project pages) or 'main' (for user/org pages).
  # Check your GitHub repo's Settings -> Pages section to confirm your "Build and deployment" source.
  githubPagesBranch: 'gh-pages' # <--- IMPORTANT: Adjust this to your GitHub Pages source branch

  # The directory where Jekyll outputs the built static files.
  # By default, Jekyll outputs to '_site'.
  jekyllOutputFolder: '_site'

  # The name of the artifact that will contain your built website files.
  artifactName: 'nextvaldata_site'

# Stages define distinct phases of your pipeline (e.g., Build, Deploy)
stages:
- stage: BuildBlog
  displayName: 'Build Jekyll Blog'
  jobs:
  - job: BuildJob
    displayName: 'Build Static Site with Jekyll'
    steps:
    - task: UseRubyVersion@0
      displayName: 'Use Ruby Version (for Jekyll)'
      inputs:
        versionSpec: '3.2' # <--- Adjust Ruby version if your Jekyll version requires it
        addToPath: true

    - script: |
        # Ensure Bundler is installed
        gem install bundler --no-document
        # Install Jekyll and other gems defined in your Gemfile.lock
        bundle install --jobs 4 --retry 3
      displayName: 'Install Jekyll Dependencies (Bundler)'

    - script: |
        # Build the Jekyll site.
        # --destination flag ensures it builds directly into the artifact staging directory.
        bundle exec jekyll build --destination "$(Build.ArtifactStagingDirectory)/$(jekyllOutputFolder)"
      displayName: 'Run Jekyll Build'

    - publish: '$(Build.ArtifactStagingDirectory)/$(jekyllOutputFolder)'
      artifact: '$(artifactName)'
      displayName: 'Publish Website Artifact'

- stage: DeployToGitHubPages
  displayName: 'Deploy to GitHub Pages'
  # This stage depends on the 'BuildBlog' stage completing successfully
  dependsOn: BuildBlog
  condition: succeeded() # Only deploy if the build was successful

  jobs:
  - job: DeployJob
    displayName: 'Push to GitHub Pages'
    steps:
    - download: current
      artifact: '$(artifactName)'
      displayName: 'Download Built Site Artifact'

    # This Bash script handles the Git operations to push to GitHub Pages.
    # It requires a GitHub Personal Access Token (PAT) for authentication.
    # IN AZURE DEVOPS: Create a Variable Group (e.g., 'GitHubSecrets')
    # and add a secret variable named 'GITHUB_PAT' with your PAT as its value.
    # Link this variable group to your pipeline.
    # The PAT needs 'repo' scope on GitHub.
- task: PowerShell@2
  displayName: 'Push to GitHub Pages'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "DEBUG: Starting deployment script."

      # Set Git user for the commit
      git config --global user.email "azure-devops@${env:BUILD_REPOSITORY_NAME}.com"
      git config --global user.name "Azure DevOps CD Pipeline"

      # --- Debugging the variable value ---
      Write-Host "DEBUG: Value of githubPagesBranch variable: '$env:githubPagesBranch'"

      # --- START OF REVISED CLONING & CHECKOUT LOGIC ---
      $repoUrl = "https://x-access-token:$($env:GITHUB_PAT)@github.com/$(Build.Repository.Name).git"
      $targetBranch = $env:githubPagesBranch
      $tempRepoDir = "temp_repo"

      Write-Host "DEBUG: Cloning repository '$repoUrl' into '$tempRepoDir'."

      # Attempt to clone the specific branch directly.
      # If the branch doesn't exist, this command will fail.
      $cloneResult = git clone --no-checkout --single-branch --branch $targetBranch $repoUrl $tempRepoDir 2>&1

      if ($LASTEXITCODE -ne 0) {
          Write-Host "DEBUG: Initial clone of '$targetBranch' failed. Trying to clone default branch and create '$targetBranch'."
          Remove-Item -LiteralPath $tempRepoDir -Force -Recurse -ErrorAction SilentlyContinue # Clean up failed clone attempt

          # Clone the default branch (usually 'main')
          git clone --no-checkout --single-branch $repoUrl $tempRepoDir
          Set-Location $tempRepoDir

          # Try to create and checkout the target branch
          git checkout -b $targetBranch
          Write-Host "DEBUG: Successfully created and checked out new branch '$targetBranch'."
          Set-Location .. # Go back to original directory before subsequent Set-Location

      }

      # Navigate into the cloned repository
      Set-Location $tempRepoDir

      # Ensure we are on the correct branch, even if it was cloned initially
      git checkout $targetBranch
      Write-Host "DEBUG: Final checkout to branch '$targetBranch' confirmed."

      # --- Debugging the actual branch after clone/checkout ---
      Write-Host "DEBUG: Current branch after all operations:"
      git branch -vv
      Write-Host "DEBUG: Git status after branch operations:"
      git status
      Write-Host "DEBUG: Git remotes:"
      git remote -v

      # --- END OF REVISED CLONING & CHECKOUT LOGIC ---


      # Remove all existing files (except .git folder) to ensure a clean deploy.
      Get-ChildItem -Path . -Force | Where-Object { $_.Name -ne '.git' } | Remove-Item -Recurse -Force
      Write-Host "DEBUG: Cleared '$tempRepoDir' directory contents."

      # Copy the newly built site files from the artifact download directory
      Copy-Item -Path "$env:PIPELINE_WORKSPACE\$env:artifactName\*" -Destination . -Recurse -Force
      Write-Host "DEBUG: Copied built site from artifact to '$tempRepoDir'."

      # --- Debugging before commit ---
      Write-Host "DEBUG: Git status after copying files:"
      git status

      # Add all changes, commit, and push to the GitHub Pages branch
      git add .
      git commit -m "Azure DevOps CD: Deployed new blog content [skip ci]" || Write-Host "DEBUG: No changes to commit, skipping commit."

      # --- Debugging before push ---
      Write-Host "DEBUG: Attempting to push to branch: $targetBranch"
      Write-Host "DEBUG: Push command output:"
      git push origin $targetBranch

      Set-Location .. # Go back to the pipeline's root working directory
      Write-Host "DEBUG: Deployment script finished."
    env:
      GITHUB_PAT: $(GITHUB_PAT)
      githubPagesBranch: $(githubPagesBranch)
      artifactName: $(artifactName)
      PIPELINE_WORKSPACE: $(Pipeline.Workspace)

