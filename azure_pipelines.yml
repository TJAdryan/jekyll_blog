# azure-pipelines.yml
# Trigger the pipeline on pushes to your content branch (e.g., 'main')
trigger:
  branches:
    include:
    - main # Or 'master', 'source', 'develop', etc., where your Jekyll source lives

# Use a Microsoft-hosted agent for your build.
# For public projects, you get unlimited minutes on these agents!
pool:
  vmImage: 'ubuntu-latest' # A recent Ubuntu image with Ruby/Bundler typically available

# Variables for easy customization
variables:
  # The branch on your GitHub repository that GitHub Pages serves from.
  # COMMON VALUES: 'gh-pages' (for project pages) or 'main' (for user/org pages).
  # Check your GitHub repo's Settings -> Pages section to confirm your "Build and deployment" source.
  githubPagesBranch: 'gh-pages' # <--- IMPORTANT: Adjust this to your GitHub Pages source branch

  # The directory where Jekyll outputs the built static files.
  # By default, Jekyll outputs to '_site'.
  jekyllOutputFolder: '_site'

  # The name of the artifact that will contain your built website files.
  artifactName: 'nextvaldata_site'

# Stages define distinct phases of your pipeline (e.g., Build, Deploy)
stages:
- stage: BuildBlog
  displayName: 'Build Jekyll Blog'
  jobs:
  - job: BuildJob
    displayName: 'Build Static Site with Jekyll'
    steps:
    - task: UseRubyVersion@0
      displayName: 'Use Ruby Version (for Jekyll)'
      inputs:
        versionSpec: '3.2' # <--- Adjust Ruby version if your Jekyll version requires it
        addToPath: true

    - script: |
        # Ensure Bundler is installed
        gem install bundler --no-document
        # Install Jekyll and other gems defined in your Gemfile.lock
        bundle install --jobs 4 --retry 3
      displayName: 'Install Jekyll Dependencies (Bundler)'

    - script: |
        # Build the Jekyll site.
        # --destination flag ensures it builds directly into the artifact staging directory.
        bundle exec jekyll build --destination "$(Build.ArtifactStagingDirectory)/$(jekyllOutputFolder)"
      displayName: 'Run Jekyll Build'

    - publish: '$(Build.ArtifactStagingDirectory)/$(jekyllOutputFolder)'
      artifact: '$(artifactName)'
      displayName: 'Publish Website Artifact'

- stage: DeployToGitHubPages
  displayName: 'Deploy to GitHub Pages'
  # This stage depends on the 'BuildBlog' stage completing successfully
  dependsOn: BuildBlog
  condition: succeeded() # Only deploy if the build was successful

  jobs:
  - job: DeployJob
    displayName: 'Push to GitHub Pages'
    steps:
    - download: current
      artifact: '$(artifactName)'
      displayName: 'Download Built Site Artifact'

    # This Bash script handles the Git operations to push to GitHub Pages.
    # It requires a GitHub Personal Access Token (PAT) for authentication.
    # IN AZURE DEVOPS: Create a Variable Group (e.g., 'GitHubSecrets')
    # and add a secret variable named 'GITHUB_PAT' with your PAT as its value.
    # Link this variable group to your pipeline.
    # The PAT needs 'repo' scope on GitHub.
- task: PowerShell@2
  displayName: 'Push to GitHub Pages'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "DEBUG: Starting deployment script."

      # Set Git user for the commit
      git config --global user.email "azure-devops@${env:BUILD_REPOSITORY_NAME}.com"
      git config --global user.name "Azure DevOps CD Pipeline"

      # --- Debugging the variable value ---
      Write-Host "DEBUG: Value of githubPagesBranch variable: '$env:githubPagesBranch'"

      # Clone the GitHub repository into a temporary directory
      # Ensure PAT is properly interpolated for the URL.
      # Use `temp_repo` as the directory name.
      # Explicitly clone the target branch (--branch). This is safer.
      git clone --branch $env:githubPagesBranch https://x-access-token:$($env:GITHUB_PAT)@github.com/$(Build.Repository.Name).git temp_repo -depth 1 || `
      # If cloning the branch directly fails (e.g., branch doesn't exist yet for first deploy),
      # then clone without a branch and create it.
      # Note: This `||` (OR) logic for PowerShell is important here.
      { Write-Host "DEBUG: Failed to clone $env:githubPagesBranch directly, cloning main and creating branch."; `
        git clone https://x-access-token:$($env:GITHUB_PAT)@github.com/$(Build.Repository.Name).git temp_repo -depth 1; `
        Set-Location temp_repo; `
        git checkout -b $env:githubPagesBranch; `
        Set-Location .. } # Go back to root before setting location again

      # Navigate into the cloned repository
      Set-Location temp_repo

      # --- Debugging the actual branch after checkout/clone ---
      Write-Host "DEBUG: Current branch after clone/checkout:"
      git branch -vv
      Write-Host "DEBUG: Git status after branch operations:"
      git status

      # Remove all existing files (except .git folder) to ensure a clean deploy.
      # This is critical for synchronizing deletions from your source.
      Get-ChildItem -Path . -Force | Where-Object { $_.Name -ne '.git' } | Remove-Item -Recurse -Force
      Write-Host "DEBUG: Cleared temp_repo directory contents."

      # Copy the newly built site files from the artifact download directory
      # Ensure the source path is correct.
      Copy-Item -Path "$env:PIPELINE_WORKSPACE\$env:artifactName\*" -Destination . -Recurse -Force
      Write-Host "DEBUG: Copied built site from artifact to temp_repo."

      # --- Debugging before commit ---
      Write-Host "DEBUG: Git status after copying files:"
      git status

      # Add all changes, commit, and push to the GitHub Pages branch
      git add .
      git commit -m "Azure DevOps CD: Deployed new blog content [skip ci]" || Write-Host "DEBUG: No changes to commit, skipping commit."

      # --- Debugging before push ---
      Write-Host "DEBUG: Attempting to push to branch: $env:githubPagesBranch"
      git remote -v # Show remote URLs
      git branch # Show local branches

      git push origin $env:githubPagesBranch
      Write-Host "DEBUG: Push command executed."

      Set-Location .. # Go back to the pipeline's root working directory
      Write-Host "DEBUG: Deployment script finished."
    env:
      GITHUB_PAT: $(GITHUB_PAT)
      githubPagesBranch: $(githubPagesBranch)
      artifactName: $(artifactName)
      PIPELINE_WORKSPACE: $(Pipeline.Workspace)