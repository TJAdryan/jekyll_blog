# azure-pipelines.yml

# Trigger the pipeline on pushes to your content branch (e.g., 'main')
# IMPORTANT: During troubleshooting, keep this commented out initially (Phase 1).
# Uncomment it only in Phase 5 after main is clean and the YAML is fully updated.
# trigger:
#   branches:
#     include:
#     - main # Or 'master', 'source', 'develop', etc., where your Jekyll source lives

# Use a Microsoft-hosted agent for your build.
# For public projects, you get unlimited minutes on these agents!
pool:
  vmImage: 'ubuntu-latest' # A recent Ubuntu image with Ruby/Bundler typically available

# --- CORRECTED VARIABLES AND VARIABLE GROUP INDENTATION ---
# Variables for easy customization
variables:
  # The branch on your GitHub repository that GitHub Pages serves from.
  # THIS MUST BE 'gh-pages' for your custom build pipeline.
  githubPagesBranch: 'gh-pages'

  # The directory where Jekyll outputs the built static files.
  # By default, Jekyll outputs to '_site'.
  jekyllOutputFolder: '_site'

  # The name of the artifact that will contain your built website files.
  artifactName: 'nextvaldata_site'

# Link to your Variable Group for secrets (like GITHUB_PAT)
# This list must be at the same level as 'variables:' and 'pool:'
# IMPORTANT: Ensure 'GitHubSecrets' is the exact name of your variable group
# where GITHUB_PAT is stored as a secret.
group: GitHubSecrets
# --- END CORRECTED VARIABLES AND VARIABLE GROUP INDENTATION ---

# Stages define distinct phases of your pipeline (e.g., Build, Deploy)
stages:
- stage: BuildBlog
  displayName: 'Build Jekyll Blog'
  jobs:
  - job: BuildJob
    displayName: 'Build Static Site with Jekyll'
    steps:
    # --- START OF CRITICAL BUILD STAGE UPDATES ---
    # Explicitly check out the source branch (main) with a clean workspace.
    # This ensures the agent starts with your pristine Jekyll source, not a cached/corrupted version.
    - checkout: self
      clean: true # <--- FORCES A CLEAN CHECKOUT. CRUCIAL FOR RESOLVING GEMFILE ISSUE.
      displayName: 'Clean Checkout of Source Branch'
    # --- END OF CRITICAL BUILD STAGE UPDATES ---

    - task: UseRubyVersion@0
      displayName: 'Use Ruby Version (for Jekyll)'
      inputs:
        versionSpec: '3.2' # <--- Adjust Ruby version if your Jekyll version requires it
        addToPath: true

    - script: |
        # Ensure Bundler is installed
        gem install bundler --no-document
        # Install Jekyll and other gems defined in your Gemfile.lock
        bundle install --jobs 4 --retry 3
      displayName: 'Install Jekyll Dependencies (Bundler)'

    - script: |
        # Build the Jekyll site.
        # --destination flag ensures it builds directly into the artifact staging directory.
        bundle exec jekyll build --destination "$(Build.ArtifactStagingDirectory)/$(jekyllOutputFolder)"
      displayName: 'Run Jekyll Build'

    - publish: '$(Build.ArtifactStagingDirectory)/$(jekyllOutputFolder)'
      artifact: '$(artifactName)'
      displayName: 'Publish Website Artifact'

- stage: DeployToGitHubPages
  displayName: 'Deploy to GitHub Pages'
  # This stage depends on the 'BuildBlog' stage completing successfully
  dependsOn: BuildBlog
  condition: succeeded() # Only deploy if the build was successful

  jobs:
  - job: DeployJob
    displayName: 'Push to GitHub Pages'
    steps:
    - download: current
      artifact: '$(artifactName)'
      displayName: 'Download Built Site Artifact'

    # --- START OF CRITICAL DEPLOYMENT SCRIPT UPDATES ---
    # This PowerShell script handles the Git operations to push to GitHub Pages.
    # It requires a GitHub Personal Access Token (PAT) for authentication.
    # Ensure you have a Variable Group (e.g., 'GitHubSecrets') linked to this pipeline,
    # and a secret variable named 'GITHUB_PAT' within it, with your PAT as its value.
    # The PAT needs 'repo' scope on GitHub.
    - task: PowerShell@2
      displayName: 'Push to GitHub Pages'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "DEBUG: Starting deployment script."

          # Set Git user for the commit
          git config --global user.email "azure-devops@${env:BUILD_REPOSITORY_NAME}.com"
          git config --global user.name "Azure DevOps CD Pipeline"

          # --- Debugging the variable value ---
          Write-Host "DEBUG: Value of githubPagesBranch variable: '$env:githubPagesBranch'"

          # --- REVISED CLONING & CHECKOUT LOGIC ---
          $repoUrl = "https://x-access-token:$($env:GITHUB_PAT)@github.com/$(Build.Repository.Name).git"
          $targetBranch = $env:githubPagesBranch
          $tempRepoDir = "temp_repo"

          Write-Host "DEBUG: Cloning repository '$repoUrl' into '$tempRepoDir'."

          # Attempt to clone the specific branch directly.
          # If the branch doesn't exist, this command will fail.
          $cloneResult = git clone --no-checkout --single-branch --branch $targetBranch $repoUrl $tempRepoDir 2>&1

          if ($LASTEXITCODE -ne 0) {
              Write-Host "DEBUG: Initial clone of '$targetBranch' failed. Trying to clone default branch and create '$targetBranch'."
              Remove-Item -LiteralPath $tempRepoDir -Force -Recurse -ErrorAction SilentlyContinue # Clean up failed clone attempt

              # Clone the default branch (usually 'main')
              git clone --no-checkout --single-branch $repoUrl $tempRepoDir
              Set-Location $tempRepoDir

              # Try to create and checkout the target branch
              git checkout -b $targetBranch