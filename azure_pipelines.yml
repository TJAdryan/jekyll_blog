# azure-pipelines.yml

# ... (previous stages and variables are the same) ...

stages:
# ... (BuildBlog stage remains unchanged) ...

- stage: DeployToGitHubPages
  displayName: 'Deploy to GitHub Pages'
  dependsOn: BuildBlog
  condition: succeeded()

  jobs:
  - job: DeployJob
    displayName: 'Push to GitHub Pages'
    pool:
      vmImage: 'ubuntu-latest' # PowerShell Core runs on Linux and Windows.
                               # If your agent is Windows, 'windows-latest' is fine too.

    steps:
    - download: current
      artifact: $(artifactName)
      displayName: 'Download Built Site Artifact'

    - script: |
        #!/usr/bin/pwsh # Explicitly tell the system to use the PowerShell interpreter
        $ErrorActionPreference = "Stop" # Exit immediately if a command exits with an error

        Write-Host "Starting deployment to GitHub Pages..."
        Write-Host "Repository: $($env:BUILD_REPOSITORY_NAME)"
        Write-Host "Target branch: $($env:GITHUBPAGESBRANCH)" # Note: pipeline variables become env vars
        Write-Host "Artifact path: $($env:PIPELINE_WORKSPACE)/$($env:ARTIFACTNAME)"

        # Set Git user for the commit
        git config --global user.email "azure-devops@$($env:BUILD_REPOSITORY_NAME).com"
        git config --global user.name "Azure DevOps CD Pipeline"

        # Clone the GitHub repository into a temporary directory
        # In PowerShell, environment variables are accessed via $env:
        git clone https://x-access-token:$($env:GITHUB_PAT)@github.com/TJAdryan/$(Build.Repository.Name).git temp_repo
        #Where is GITHUB_PAT?
        # Navigate into the cloned repository
        Set-Location temp_repo

        # Checkout the GitHub Pages branch. Create it if it doesn't exist.
        try {
            git checkout $($env:GITHUBPAGESBRANCH)
        } catch {
            git checkout -b $($env:GITHUBPAGESBRANCH)
        }
        Write-Host "Checked out branch $($env:GITHUBPAGESBRANCH)"

        # Clean the branch: Remove all existing files (except .git folder)
        # Get-ChildItem and Remove-Item are PowerShell equivalents for 'ls' and 'rm'
        Get-ChildItem -Path . -Exclude '.git' -Force | Remove-Item -Recurse -Force
        Write-Host "Cleaned existing files on branch $($env:GITHUBPAGESBRANCH)"

        # Copy the newly built site files from the artifact download directory
        # The artifact will be downloaded to $(Pipeline.Workspace)/$(artifactName)
        Copy-Item -Path "$($env:PIPELINE_WORKSPACE)/$($env:ARTIFACTNAME)/*" -Destination . -Recurse -Force
        Copy-Item -Path "$($env:PIPELINE_WORKSPACE)/$($env:ARTIFACTNAME)/.*" -Destination . -Recurse -Force -ErrorAction SilentlyContinue # For hidden files
        Write-Host "Copied new site files to temp_repo"

        # Add all changes, commit, and push to the GitHub Pages branch
        git add .
        # The '[skip ci]' in the commit message prevents GitHub Actions (if configured)
        # from triggering an infinite build loop based on this commit.
        try {
            git commit -m "Azure DevOps CD: Deployed new blog content - Build $($env:BUILD_BUILDID) [skip ci]"
            Write-Host "Committed changes."
        } catch {
            Write-Host "No changes to commit."
        }

        git push origin $($env:GITHUBPAGESBRANCH)
        Write-Host "Successfully pushed to GitHub Pages!"
      displayName: 'Push Built Site to GitHub Pages (PowerShell)'
      env:
        # This makes the value of $(GITHUB_PAT) (resolved by Azure DevOps) available
        # as an environment variable named GITHUB_PAT to the PowerShell script.
        GITHUB_PAT: $(GITHUB_PAT)

        # It's good practice to explicitly map other pipeline variables
        # you want to use as environment variables in the script:
        ARTIFACTNAME: $(artifactName)
        GITHUBPAGESBRANCH: $(githubPagesBranch)
        BUILD_REPOSITORY_NAME: $(Build.Repository.Name)
        BUILD_BUILDID: $(Build.BuildId)
        PIPELINE_WORKSPACE: $(Pipeline.Workspace)